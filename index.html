#include <iostream> 
#include <fstream> 
#include <windows.h> 
using namespace std;

struct Person
{
    string name;
    int first_mark;
    int second_mark;
    int third_mark;
    int forth_mark;
} A;

void main() {
    setlocale(LC_ALL, "rus");

    const char* nameA = "C:/Users/Admin/source/repos/ANSWER.bin";
    ofstream fR;
    ifstream fA;
    fstream fN;

    const char* nameN = "C:/Users/Admin/source/repos/REQUEST.bin";
    long pred_size;
    int answer;

    while (true)
    {
        cout << "Введите имя: ";
        cin >> A.name;
        cout << "Введите 4 оценки (каждая от 0 до 100):" << endl;

        cout << "Первая оценка: ";
        cin >> A.first_mark;
        cout << "Вторая оценка: ";
        cin >> A.second_mark;
        cout << "Третья оценка: ";
        cin >> A.third_mark;
        cout << "Четвертая оценка: ";
        cin >> A.forth_mark;

        // Проверка корректности введенных данных
        if (A.first_mark < 0 || A.first_mark > 100 ||
            A.second_mark < 0 || A.second_mark > 100 ||
            A.third_mark < 0 || A.third_mark > 100 ||
            A.forth_mark < 0 || A.forth_mark > 100) {
            cout << "Ошибка: все оценки должны быть в диапазоне от 0 до 100!" << endl;
            continue;
        }

        string s = "C:/Users/Admin/source/repos/" + A.name + ".bin";
        const char* nameR = s.c_str();

        fR.open(nameR, ios::app | ios::binary);
        fR.write((char*)&A, sizeof(A));
        fR.close();

        fN.open(nameN, ios::app | ios::binary);
        fN.write((char*)&A.name, sizeof(A.name));
        fN.close();

        fA.open(nameR, ios::binary);
        fA.seekg(0, ios::end);
        pred_size = fA.tellg();

        while (pred_size >= fA.tellg())
        {
            Sleep(100);
            fA.seekg(0, ios::end);
        }

        fA.seekg(pred_size, ios::beg);
        fA.read((char*)&answer, sizeof(answer));
        fA.close();

        cout << "Результат для студента " << A.name << ":" << endl;
        cout << "Сумма баллов: " << (A.first_mark + A.second_mark + A.third_mark + A.forth_mark) << endl;

        switch (answer) {
        case 2: { cout << "Оценка: 2 (неудовлетворительно)"; break; }
        case 3: { cout << "Оценка: 3 (удовлетворительно)"; break; }
        case 4: { cout << "Оценка: 4 (хорошо)"; break; }
        case 5: { cout << "Оценка: 5 (отлично)"; break; }
        default: { cout << "Ошибка вычисления оценки"; break; }
        }
        cout << endl << "------------------------" << endl;
    }
}


#include <iostream> 
#include <fstream> 
#include <windows.h> 
using namespace std;

struct Person
{
    string name;
    int first_mark;
    int second_mark;
    int third_mark;
    int forth_mark;
}B;

int answer;
long size_pred;
long size_pred_name;

int calculateGrade(int score) {
    if (score >= 0 && score <= 49) return 2;   // неудовлетворительно
    if (score >= 50 && score <= 74) return 3;  // удовлетворительно
    if (score >= 75 && score <= 89) return 4;  // хорошо
    if (score >= 90 && score <= 100) return 5; // отлично
    return 2; // по умолчанию неудовлетворительно
}

int main() {
    ifstream fR;
    ofstream fA;
    ifstream fN;
    setlocale(LC_ALL, "rus");

    const char* nameN = "C:/Users/Admin/source/repos/REQUEST.bin";
    const char* nameA = "C:/Users/Admin/source/repos/ANSWER.bin";

    fN.open(nameN, ios::binary);
    fN.seekg(0, ios::end);
    size_pred_name = fN.tellg();
    fN.close();

    cout << "Server is working" << endl;

    while (true)
    {
        fN.open(nameN, ios::binary);
        fN.seekg(0, ios::end);

        while (size_pred_name >= fN.tellg())
        {
            Sleep(100);
            fN.seekg(0, ios::end);
        }

        fN.seekg(size_pred_name, ios::beg);
        fN.read((char*)&B.name, sizeof(B.name));
        size_pred_name = fN.tellg();
        fN.close();

        string s = "C:/Users/Admin/source/repos/" + B.name + ".bin";
        const char* nameR = s.c_str();

        fR.open(nameR, ios::binary);
        fR.seekg(ios::beg, 0);
        fR.read((char*)&B, sizeof(B));

        // Рассчитываем общую сумму баллов
        int total_score = B.first_mark + B.second_mark + B.third_mark + B.forth_mark;

        // Определяем оценку по критериям
        answer = calculateGrade(total_score);

        fR.close();

        cout << "Сервер обработал данные студента " << B.name << endl;
        cout << "Баллы: " << B.first_mark << ", " << B.second_mark << ", "
            << B.third_mark << ", " << B.forth_mark << endl;
        cout << "Сумма баллов: " << total_score << ", Оценка: " << answer << endl;

        fA.open(nameR, ios::binary | ios::app);
        fA.write((char*)&answer, sizeof(answer));
        fA.close();
    }
}

#include <iostream> 
#include <fstream> 
#include <windows.h> 
#include <string>
using namespace std; 

struct Person 
{ 
    char name[100];  // Изменено на фиксированный массив char
    int first_mark; 
    int second_mark; 
    int third_mark; 
    int forth_mark; 
} A; 

int main() {  // main должен возвращать int
    setlocale(LC_ALL, "rus"); 
    
    const char* nameA = "ANSWER.bin"; 
    ofstream fR; 
    ifstream fA; 
    fstream fN; 
    
    const char* nameN = "REQUEST.bin"; 
    long pred_size; 
    int answer; 
    
    while (true) 
    { 
        cout << "Введите имя: "; 
        cin >> A.name; 
        cout << "Введите 4 оценки (каждая от 0 до 100):" << endl; 
        
        cout << "Первая оценка: ";
        cin >> A.first_mark;
        cout << "Вторая оценка: ";
        cin >> A.second_mark;
        cout << "Третья оценка: ";
        cin >> A.third_mark;
        cout << "Четвертая оценка: ";
        cin >> A.forth_mark;
        
        // Исправлено условие проверки
        if (A.first_mark < 0 || A.first_mark > 100 ||
            A.second_mark < 0 || A.second_mark > 100 ||
            A.third_mark < 0 || A.third_mark > 100 ||
            A.forth_mark < 0 || A.forth_mark > 100) {
            cout << "Ошибка: все оценки должны быть в диапазоне от 0 до 100!" << endl;
            continue;
        }
        
        string s = A.name + string(".bin"); 
        const char* nameR = s.c_str(); 
        
        fR.open(nameR, ios::binary); 
        fR.write((char*)&A, sizeof(A)); 
        fR.close(); 
        
        fN.open(nameN, ios::app | ios::binary); 
        fN.write(A.name, sizeof(A.name)); 
        fN.close(); 
        
        // Ожидание ответа от сервера
        fA.open(nameR, ios::binary); 
        fA.seekg(0, ios::end); 
        pred_size = fA.tellg(); 
        
        // Ждем пока файл не изменится
        while (pred_size >= fA.tellg()) 
        { 
            Sleep(100); 
            fA.seekg(0, ios::end); 
        } 
        
        // Читаем ответ с конца файла
        fA.seekg(-static_cast<int>(sizeof(answer)), ios::end);
        fA.read((char*)&answer, sizeof(answer)); 
        fA.close(); 
        
        cout << "Результат для студента " << A.name << ":" << endl;
        int total_score = A.first_mark + A.second_mark + A.third_mark + A.forth_mark;
        cout << "Сумма баллов: " << total_score << endl;
        
        switch (answer) { 
            case 2: {cout << "Оценка: 2 (неудовлетворительно)"; break; } 
            case 3: {cout << "Оценка: 3 (удовлетворительно)"; break; } 
            case 4: {cout << "Оценка: 4 (хорошо)"; break; } 
            case 5: {cout << "Оценка: 5 (отлично)"; break; } 
            default: {cout << "Ошибка вычисления оценки"; break; }
        } 
        cout << endl << "------------------------" << endl; 
    } 
    return 0;
}
    #include <iostream> 
#include <fstream> 
#include <windows.h> 
#include <string>
using namespace std; 

struct Person 
{ 
    char name[100];  // Изменено на фиксированный массив char
    int first_mark; 
    int second_mark; 
    int third_mark; 
    int forth_mark; 
} B; 

int answer; 
long size_pred_name; 

// Исправленная функция расчета оценки
int calculateGrade(int total_score) {
    if (total_score >= 0 && total_score <= 199) return 2;   // 0-49.75 средний балл
    if (total_score >= 200 && total_score <= 299) return 3; // 50-74.75 средний балл  
    if (total_score >= 300 && total_score <= 359) return 4; // 75-89.75 средний балл
    if (total_score >= 360 && total_score <= 400) return 5; // 90-100 средний балл
    return 2; // по умолчанию
}

int main() { 
    ifstream fR; 
    ofstream fA; 
    ifstream fN; 
    setlocale(LC_ALL, "rus"); 
    
    const char* nameN = "REQUEST.bin"; 
    const char* nameA = "ANSWER.bin"; 
    
    fN.open(nameN, ios::binary); 
    fN.seekg(0, ios::end); 
    size_pred_name = fN.tellg(); 
    fN.close(); 
    
    cout << "Server is working" << endl; 
    
    while (true) 
    { 
        fN.open(nameN, ios::binary); 
        fN.seekg(0, ios::end); 
        
        while (size_pred_name >= fN.tellg()) 
        { 
            Sleep(100); 
            fN.seekg(0, ios::end); 
        } 
        
        fN.seekg(size_pred_name, ios::beg); 
        fN.read((char*)&B.name, sizeof(B.name)); 
        size_pred_name = fN.tellg(); 
        fN.close(); 
        
        string s = string(B.name) + ".bin"; 
        const char* nameR = s.c_str(); 
        
        fR.open(nameR, ios::binary); 
        if (!fR.is_open()) {
            cout << "Ошибка открытия файла: " << nameR << endl;
            continue;
        }
        
        fR.read((char*)&B, sizeof(B)); 
        
        // Рассчитываем общую сумму баллов (0-400)
        int total_score = B.first_mark + B.second_mark + B.third_mark + B.forth_mark;
        
        // Определяем оценку по общей сумме
        answer = calculateGrade(total_score);
        
        fR.close(); 
        
        cout << "Сервер обработал данные студента " << B.name << endl;
        cout << "Баллы: " << B.first_mark << ", " << B.second_mark << ", " 
             << B.third_mark << ", " << B.forth_mark << endl;
        cout << "Сумма баллов: " << total_score << ", Оценка: " << answer << endl;
        
        // Записываем ответ в конец файла студента
        fA.open(nameR, ios::binary | ios::app); 
        fA.write((char*)&answer, sizeof(answer)); 
        fA.close(); 
    } 
    return 0;
}                                                    
#include <iostream> 
#include <fstream> 
#include <windows.h> 
#include <string>
using namespace std; 

struct Person 
{ 
    char name[50];  // Фиксированный размер для надежности
    int first_mark; 
    int second_mark; 
    int third_mark; 
    int forth_mark; 
} A; 

int main() {
    setlocale(LC_ALL, "rus"); 
    
    const char* nameN = "REQUEST.bin"; 
    long pred_size; 
    int answer; 
    
    while (true) 
    { 
        cout << "Введите имя: "; 
        cin >> A.name; 
        cout << "Введите 4 оценки (каждая от 0 до 100):" << endl; 
        
        cout << "Первая оценка: ";
        cin >> A.first_mark;
        cout << "Вторая оценка: ";
        cin >> A.second_mark;
        cout << "Третья оценка: ";
        cin >> A.third_mark;
        cout << "Четвертая оценка: ";
        cin >> A.forth_mark;
        
        // Проверка корректности введенных данных
        if (A.first_mark < 0 || A.first_mark > 100 ||
            A.second_mark < 0 || A.second_mark > 100 ||
            A.third_mark < 0 || A.third_mark > 100 ||
            A.forth_mark < 0 || A.forth_mark > 100) {
            cout << "Ошибка: все оценки должны быть в диапазоне от 0 до 100!" << endl;
            continue;
        }
        
        string s = string(A.name) + ".bin"; 
        const char* nameR = s.c_str(); 
        
        // Записываем данные студента в его файл
        ofstream fR(nameR, ios::binary); 
        if (!fR) {
            cout << "Ошибка создания файла студента!" << endl;
            continue;
        }
        fR.write((char*)&A, sizeof(A)); 
        fR.close(); 
        
        // Добавляем имя в очередь запросов
        fstream fN(nameN, ios::app | ios::binary); 
        if (!fN) {
            cout << "Ошибка открытия файла запросов!" << endl;
            continue;
        }
        fN.write(A.name, sizeof(A.name)); 
        fN.close(); 
        
        cout << "Ожидание ответа от сервера..." << endl;
        
        // Ожидаем ответ от сервера
        bool answer_received = false;
        int attempts = 0;
        
        while (!answer_received && attempts < 50) { // Максимум 5 секунд ожидания
            ifstream fA(nameR, ios::binary); 
            if (fA) {
                fA.seekg(0, ios::end);
                long current_size = fA.tellg();
                
                // Если файл содержит данные помимо структуры Person
                if (current_size > static_cast<long>(sizeof(A))) {
                    // Читаем ответ с конца файла
                    fA.seekg(sizeof(A), ios::beg); // Ответ записан после структуры
                    fA.read((char*)&answer, sizeof(answer));
                    
                    if (fA.good()) {
                        answer_received = true;
                        cout << "Результат для студента " << A.name << ":" << endl;
                        int total_score = A.first_mark + A.second_mark + A.third_mark + A.forth_mark;
                        cout << "Сумма баллов: " << total_score << endl;
                        
                        switch (answer) { 
                            case 2: {cout << "Оценка: 2 (неудовлетворительно)"; break; } 
                            case 3: {cout << "Оценка: 3 (удовлетворительно)"; break; } 
                            case 4: {cout << "Оценка: 4 (хорошо)"; break; } 
                            case 5: {cout << "Оценка: 5 (отлично)"; break; } 
                            default: {cout << "Ошибка вычисления оценки"; break; }
                        } 
                        cout << endl << "------------------------" << endl;
                    }
                }
                fA.close();
            }
            
            if (!answer_received) {
                Sleep(100); // Ждем 100ms
                attempts++;
            }
        }
        
        if (!answer_received) {
            cout << "Сервер не ответил в течение 5 секунд!" << endl;
        }
    } 
    return 0;
}
  #include <iostream> 
#include <fstream> 
#include <windows.h> 
#include <string>
using namespace std; 

struct Person 
{ 
    char name[50];  // Фиксированный размер для надежности
    int first_mark; 
    int second_mark; 
    int third_mark; 
    int forth_mark; 
} B; 

int answer; 
long size_pred_name = 0;

// Функция расчета оценки
int calculateGrade(int total_score) {
    if (total_score >= 0 && total_score <= 199) return 2;   // 0-199 = 2
    if (total_score >= 200 && total_score <= 299) return 3; // 200-299 = 3
    if (total_score >= 300 && total_score <= 359) return 4; // 300-359 = 4
    if (total_score >= 360 && total_score <= 400) return 5; // 360-400 = 5
    return 2; // по умолчанию
}

int main() { 
    setlocale(LC_ALL, "rus"); 
    
    const char* nameN = "REQUEST.bin"; 
    
    // Создаем файл запросов если его нет
    fstream testFile(nameN, ios::app | ios::binary);
    testFile.close();
    
    cout << "Сервер запущен и ожидает запросы..." << endl; 
    
    while (true) 
    { 
        ifstream fN(nameN, ios::binary); 
        if (!fN.is_open()) {
            cout << "Ошибка открытия файла запросов!" << endl;
            Sleep(1000);
            continue;
        }
        
        fN.seekg(0, ios::end); 
        long current_size = fN.tellg();
        
        // Если есть новые запросы
        if (current_size > size_pred_name) {
            fN.seekg(size_pred_name, ios::beg); 
            
            // Обрабатываем все новые запросы
            while (fN.tellg() < current_size) {
                fN.read(B.name, sizeof(B.name)); 
                
                string s = string(B.name) + ".bin"; 
                const char* nameR = s.c_str(); 
                
                cout << "Обработка студента: " << B.name << endl;
                
                // Читаем данные студента
                ifstream fR(nameR, ios::binary); 
                if (fR.is_open()) {
                    fR.read((char*)&B, sizeof(B)); 
                    
                    if (fR.good()) {
                        // Рассчитываем общую сумму баллов
                        int total_score = B.first_mark + B.second_mark + B.third_mark + B.forth_mark;
                        
                        // Определяем оценку
                        answer = calculateGrade(total_score);
                        
                        fR.close(); 
                        
                        cout << "Данные студента " << B.name << ":" << endl;
                        cout << "Баллы: " << B.first_mark << ", " << B.second_mark 
                             << ", " << B.third_mark << ", " << B.forth_mark << endl;
                        cout << "Сумма баллов: " << total_score << ", Оценка: " << answer << endl;
                        cout << "----------------------------------------" << endl;
                        
                        // Записываем ответ в файл студента
                        ofstream fA(nameR, ios::binary | ios::app); 
                        if (fA.is_open()) {
                            fA.write((char*)&answer, sizeof(answer)); 
                            fA.close();
                        } else {
                            cout << "Ошибка записи ответа для " << B.name << endl;
                        }
                    } else {
                        cout << "Ошибка чтения данных студента: " << B.name << endl;
                        fR.close();
                    }
                } else {
                    cout << "Не удалось открыть файл студента: " << nameR << endl;
                }
                
                // Обновляем позицию для следующего чтения
                size_pred_name = fN.tellg();
            }
        }
        fN.close(); 
        
        Sleep(500); // Проверяем новые запросы каждые 500ms
    } 
    return 0;
}                                                               
